# 今回のテーマ：ラムダ計算を楽しもう！

# 第１回　真偽値と数値とたし算、かけ算

# はじめに

## 経緯

よく「コンピュータは所詮 0 と 1 しかない」「プログラムは順序・分岐・繰り返ししかない」とか言われがちですが、ある側面においては正解でありつつも、別の側面においては不正解でもあります。

ただ、実際のコンピュータが電気の ON/OFF で表現されるため、0 と 1 で構成されるというのは間違いのない事実です。
ですが、本当に「0 と 1」あるいは「順序・分岐・繰り返し」がないとプログラムが書けないのでしょうか？

そんなことはありません、他の要素があればプログラミングは可能です。
コンピュータ（プログラム）の能力は「チューリング等価」言われ、仮想的な機械であるチューリングマシンと同等の計算能力を持つと広く認識されています。
チューリングマシンを表現できる計算モデルは、たくさんの種類が存在しています。
今回は関数型言語の根源的な計算モデルである「ラムダ計算」を取り上げます。

## 難易度

Level: 最初は簡単

今回も置き去りにならないようしっかりついてきてください。

## 対象の読者

- 関数型言語の根底にあるラムダ計算に興味のある人。
- もちろん上記に当てはまらない人にもおすすめです。

## 目標

このテーマでの目標は、ラムダ関数の持つ能力だけで型なしラムダ計算を行います。
チューリングマシンを実装して、ラムダ計算がチューリング等価であることを証明します。
現在の予定では以下のように進めます。

- ラムダ計算の基礎と真偽値
- 数値とたし算、かけ算
- ひき算とわり算
- リスト構造とリストの処理、(Y|Z)コンビネータ
- 無限に長いテープと評価器

## 用意するもの

- 推奨: 紙とペン
- なければ: パソコン

# ラムダ計算とは

## 型無しラムダ計算とは

- この記事では型無しラムダ計算を扱います。
- 関数計算の基本的な理論体系で計算機科学などの基礎となっています。

## ラムダ計算の記法

ラムダ計算は通常、その名の通り λ(ラムダ)を使った表記をします。

```
λaf.fa
// または
λa.λf.fa
```

この表記を見て、何が書いてあるか分からないと感じる人も多いでしょう。
これは Javascript だと以下の様に表現されます。

```
a => f => f(a)
// または
a => {
  return f => {
    return f(a)
  }
}
```

本記事では、読者が簡単にプログラムを実行できるように、表記は JavaScript に統一しています。

## ラムダ計算の構成要素

ラムダ計算の式は以下の３種類から構成されます。ついでに、ラムダ計算にはどのような要素が存在しないのかも明記しておきます。

| ラムダ計算にある機能 | 説明                                                                                                                                                               | Javascript でのコード例 |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------- |
| 変数                 | 普通のプログラミングと同様に値を参照できます。再代入（上書き）はできません。                                                                                       | `a`とか`f`のことです。  |
| 抽象                 | `x => e` の形を持ち、変数`x`とラムダ計算の式`e`から構成されます。れは、「引数 x を受け取り、式 e の結果を返す関数」を表します。                                    | `f(a)`です。            |
| 適用                 | 形式`f(a)`のように２つのラムダ計算の式`f`と`e`から構成されます。上記は「`f`と評価される関数に`e`と評価される値を引数として適用する（呼び出す）こと」を表現します。 | `a => f => f(a)`        |

| ラムダ計算に存在しない機能              | 対策                           |
| --------------------------------------- | ------------------------------ |
| 真偽値とその操作、数値、文字列          | 全て自分で作る必要があります。 |
| 配列やリスト、構造体やクラス            | 全て自分で作る必要があります。 |
| 上記を操作するための命令(and,or+,-,new) | 全て自分で作る必要があります。 |
| if や for/while など                    | 全て自分で作る必要があります。 |

もうちょっと説明すると、変数はあるけれど、その値は関数しか存在しません。
`f(a)`は`f`も`a`も関数で、`f(a)の計算結果`も当然関数です。

## カリー化

普通のプログラミング言語とは異なり、ラムダ計算にはもう一つ制約があります。
それは、すべての関数が一つの引数しか取らない、というものです。

最初は少し驚くかもしれませんが、これは大きな問題ではありません。
複数の引数を必要とする場合は、`f(a)(b)(c)`のように引数を一つずつ与えることで対応します。

以下で Javascript でカリー化をしてみます。
この方式を採用することで、計算が便利になる場面もあるようです。

```
const ADD = a => b => a+b // 2つ引数を取る関数を定義
const ADD_TWO = ADD(2) // 引数'a'に2を先に与えた関数を生成
console.log(ADD(2)(3)) // 5  カリー化せずに2 + 3を実行
console.log(ADD_TWO(3)) // 5 すでに2を引数に持つ関数に3を適用
console.log(ADD_TWO(10)) // 12 すでに2を引数に持つ関数に10を適用
```

# 真偽値と if

では、ラムダ計算をやってみよう。
TRUE,FALSE,IF は以下のように関数で表すことができます。
ソースコードは通常の Javascript を使用しているので、実行して動作を確認することができます。

```
// 定義
const TRUE = x => y => x
const FALSE = x => y => y
const IF = c => x => y => c(x)(y)
// 説明用コード
const TO_BOOLEAN = b => b(true)(false)
TO_BOOLEAN(TRUE) // true
console.log(IF(TRUE)("yes")("no")) // "yes"
console.log(IF(FALSE)("yes")("no")) // "no"
```

簡単ですね。
TRUE と FALSE は、それぞれ必要とする引数を返すだけの関数です。
IF は真偽値 c を引数にとり、それに基づいて必要な処理を行います。

ここでソースコードの読み方について注意してほしいことがあります。
ここのコードでは`真`に当たるのが`x=>y=>x`であると書いてありますが、`const TRUE = `の部分はラムダ計算に必須ではありません。
これは Javascript で実行するために、便宜上変数に格納しているだけです。
同様に、説明用コードもラムダ計算の機能を示すために記述したもので、ラムダ計算自体には必須ではありません。
（なので、説明用コードには文字列や数値が登場しますがそこは切り分けて考えてください。）

## 数値

基点 n に対して、操作 p を m 回繰り返し適用することで数値を表現できます。

```
// 定義
const ZERO  = p => n =>       n
const ONE   = p => n =>     p(n)
const TWO   = p => n =>   p(p(n))
const THREE = p => n => p(p(p(n)))
// 説明用コード
const TO_INT = x => x(n=>n+1)(0)
console.log(TO_INT(TWO)) // 2
```

え、こんなんでいいの？って気がしますね！
また、実は ZERO は FALSE と同じ関数であるのもポイントです。

## 0 との比較

数値が`0と等しいか`という判定は、プログラミングにおいて必要な処理ですよね！

```
// 定義
const IS_ZERO = n => n(x=>x(FALSE))(TRUE)
// 説明用コード
console.log(TO_BOOL(IS_ZERO(ZERO))) // TRUE
console.log(TO_BOOL(IS_ZERO(TWO))) // FALSE
```

もう少し丁寧に説明します。

- ZERO のとき
  - IS_ZERO(ZERO)
  - (n=>n(x=>x(FALSE))(TRUE))(ZERO) // IS_ZERO を展開
  - ZERO(x=>x(FALSE))(TRUE) // n は ZERO
  - TRUE // ZERO は FALSE と同じで第２引数を返す
- TWO のとき
  - IS_ZERO(ZERO)
  - (n=>n(x=>x(FALSE))(TRUE))(TWO) // IS_ZERO を展開
  - TWO(x=>x(FALSE))(TRUE) // n は TWO
  - (p=>n=>p(p(n)))(x=>x(FALSE))(TRUE) // TWO を展開
  - (n=>(x=>x(FALSE))((x=>x(FALSE))(n)))(TRUE) // p は x=>x(FALSE)
  - (x=>x(FALSE))((x=>x(FALSE))(TRUE)) // n は TRUE
  - (x=>x(FALSE))(TRUE(FALSE)) // (x=>x(FALSE))(TRUE)において、x は TRUE
  - TRUE(FALSE)(FALSE) // x は TRUE
  - FALSE //TRUE は第 1 引数を返す

これを手書きで行うと、大きな達成感を感じることができます。
ぜひ手書きで計算してみてください。

## 数値演算

### INC

基礎的な計算力を得るために INC(increment,+1)を実装する必要があります。

```
// 定義
const INC = n => p => x => x(n(p)(x))
// 確認用コード
const INC_TWO = INC(TWO)
console.log(TO_INT(INC_TWO)) // 3
```

パッと見で理解するのは少し難しくなってきたかもしれませんが、問題ありません。
上記の INC(TWO)を考えてみましょう。

```
変数が他と重複しないように、TWO を a => b => a(a(b)) と書き換えて考えます。

INC(TWO)
= (n => p => x => p(n(p))(x))(TWO)  // INCを展開
= p => x => p(TWO(p)(x))  // nにTWOを代入
= p => x => p(a=>b=>a(a(b))(p)(x)) // TWOはa => b => a(a(b))
= p => x => p(b => p(p(b))(x)) // aにpを代入
= p => x => p(p(p(x))) // bにxを代入
= THREE // xにpを３回適用するのはまさしくTHREEですね。
```

インクリメント（+1）を行うだけでも、これだけの手間がかかるんですね！

### たし算とかけ算

INC を使うと、たし算とかけ算ができるようになります。
ついでに累乗も定義できます。

```
const ADD = m => n => n(INC)(m) // m+n
const MUL = m => n => n(ADD(m))(ZERO) // m*n
const POW = m => n => n(MUL(m))(ONE) // m^n
// 確認用コード
console.log(TO_INT(ADD(TWO)(THREE))) // 5
console.log(TO_INT(MUL(TWO)(THREE))) // 6
console.log(TO_INT(POW(TWO)(THREE))) // 8
```

ADD の説明をします。
残る二つは同じように展開できます。

```
ADD(TWO)(THREE)
= (m=>n=>n(INC)(m))(TWO)(THREE) // ADDを展開
= THREE(INC)(TWO)// mはTWO、nはTHREE
= (a=>b=>a(a(a(b))))(INC)(TWO) // THREEを展開
= INC(INC(INC(TWO))) // aはTHREE
= FIVE // ここでは定義していないですが、これは FIVE に相当します
```

上記の計算は以下のようにも考えた方が簡単かもしれません。
ADD は n にｍ回 1 を足す → ADD(2)(3) = 2 + 1 + 1 + 1 = 5
MUL は ZERO に n を m 回足す → MUL(2)(3) = 0 + 2 + 2 + 2 = 6
ADD(m)は一つの引数 n をとり、n に m を足した結果を返します
POW は ONE にｍ回 n をかける → POW(2)(3) = 1 _ 2 _ 2 \* 2 = 8

# 今回はここまで

ラムダ計算の概要から、真偽値と if、数値とたし算かけ算までできるようになりましたね。
チューリング等価な性能を得るためには、まだまだ実装しないといけない機能がありますが、
何となく計算可能な気がしてきますよね。

次回は引き算と割り算を取り上げます。
どうしてたし算やかけ算と一緒に登場しなかったのでしょうか？
それはたし算かけ算よりずっと難しいからです。
もし余裕があるなら、次回の掲載までに DEC(引数-1 を返す)を考えてみてください。
これを自力で解くことができたら、それは非常に大きな達成感に繋がるでしょう。
（私には無理でした。）
